#!/usr/bin/python
# used to parse files more easily
from __future__ import with_statement

# Qt4 bindings for core Qt functionalities (non-GUI)
from PyQt4 import QtCore
# Python Qt4 bindings for GUI objects
from PyQt4 import QtGui
# import the MainWindow widget from the converted .ui files
from winch_gui import Ui_MainWindow # last line: from PyKDE4.kdeui import KLed

import Queue

import datetime as dt
from tzlocal import get_localzone
import time
import os
import csv
import numpy as np
import sys

from com_port import ComPort
from eblib.utils import get_all_from_queue, get_item_from_queue
from livedatafeed import LiveDataFeed

from matplotlib import ticker
import matplotlib.dates as mdates
#from matplotlib.dates import DateFormatter

#import matplotlib.dates as mdates
#import matplotlib as mpl
#import matplotlib.pyplot as plt
#from matplotlib import colors, ticker
#from matplotlib.colors impor LogNorm

class DesignerMainWindow(QtGui.QMainWindow, Ui_MainWindow):
  """Customization for Qt Designer created window"""
  def __init__(self, parent = None):
    # initialization of the superclass
    super(DesignerMainWindow, self).__init__(parent)
    # setup the GUI --> function generated by pyuic4
    self.setWindowTitle("Double Winch Monitor")
    self.setupUi(self)
    self.ui = Ui_MainWindow()
    
    #self.ui.setupUi(self)
 
 # connect the signals with the slots
    # Menu actions:
    QtCore.QObject.connect(self.filePath, QtCore.SIGNAL('triggered()'), self.select_file)
    QtCore.QObject.connect(self.actionQuit, QtCore.SIGNAL('triggered()'), QtGui.qApp,QtCore.SLOT("quit()"))
    QtCore.QObject.connect(self.openCom, QtCore.SIGNAL('triggered()'), self.select_COM)
    
    QtCore.QObject.connect(self.recordButton, QtCore.SIGNAL("clicked()"),self.record)
       
    QtCore.QObject.connect(self.analyseButton, QtCore.SIGNAL("clicked()"), self.analyse_data)
    QtCore.QObject.connect(self.monitorButton, QtCore.SIGNAL("clicked()"), self.monitor)
    QtCore.QObject.connect(self.comboBox, QtCore.SIGNAL("currentIndexChanged(QString)"), self.monitor)
    #QtCore.QObject.connect(self.yaxischeckBox QtCore.SIGNAL("isChecked()")), self.monitor)
    
    self.recordButton.setText('Start record') 
    
    self.monitor = False
    self.com_monitor = None
    self.com_data_q = None
    self.com_error_q = None
    self.livefeed = LiveDataFeed()
    #self.USE_TZ = True
    
    self.u1_delta = {'ta': 0, 'ps':0, 'hur': 0 }
    self.u2_delta = {'ta': 0, 'ps':0, 'hur': 0 }
    self.u3_delta = {'ta': 0, 'ps':0, 'hur': 0 }
    self.u4_delta = {'ta': 0, 'ps':0, 'hur': 0 }
    
    self.ps_ref = 1013.25  # reference pressure
  
    filename = dt.datetime.today().strftime('%Y%m%d')    
    home = os.path.expanduser("~")
    if not os.path.exists(home + '/data/winch/'):
      os.makedirs(home + '/data/winch/')
    outdir = (home + '/data/winch/')
    self.filelineEdit.setText(outdir + 'data_' + filename + '.csv')
    
    #self.timer = QtCore.QTimer()
    #self.com_port =  str(self.COMlineEdit.text())
        
  def select_file(self):
    """opens a file select dialog"""
    # open the dialog and get the selected file
    file = QtGui.QFileDialog.getOpenFileName()
    # if a file is selected
    if file:
      # update the lineEdit text with the selected filename
      self.filelineEdit.setText(file)

  def parse_file(self):
    #"""Parse a text file to extract letters frequencies"""
    filename = str(self.filelineEdit.text())
    
    lines = np.loadtxt( filename , dtype=str, comments="#", delimiter=',', unpack=False)
    x = [np.float(s) for s in lines[:,1]]
    y = [np.float(s) for s in lines[:,3]]
    z = [np.float(s) for s in lines[:,2]]
    
    ##lines[:,1].astype(np.float) #np.array([dt.datetime.strptime(s + t , "%d.%m.%y%H:%M:%S") for s , t   in lines[:,0:2]])
    #print self.z_samples [0:10]
    ##ta = lines[:,2].astype(np.float)
    ##pa = lines[:,3].astype(np.float)
    return x, y, z # times, ta, pa 
    
  def select_COM(self):
    """opens a COM Port select dialog"""
    # open the dialog and get the selected file
    #self.com_port = 
    ## if a file is selected
    #if self.com_port:
    ## update the lineEdit text with the selected filename
    self.COMlineEdit.setText(QtGui.QFileDialog.getOpenFileName())
      
  def monitor(self):
    """ Updates the state of the monitor window with new data. The livefeed is used to find out whether new data was received since the last update. If not, nothing is updated."""
    
    self.mpl.canvas.ax.clear()
    
    csvpath = self.filelineEdit.text()
    
    var = []
    alt = []
    ts = []
    
    # 2014-08-25 09:43:13.297405	25580	19.5	1007.02	18.9	53.48	nan	360	51.989418516	735	2	19	-20	10	974	44	-265	40	1016

    # 2014-08-20 10:34:57.130796	71580	17.4	1004.52	14.8	62.04	nan	360	72.9251906717	784	2
    data = np.loadtxt(open(csvpath,"rb"), usecols=[1,2,3,4,5,6,7,8],delimiter=",") #,skiprows=1)
    ts = np.loadtxt(open(csvpath,"rb"), usecols=[0],delimiter=",", dtype='str') # dtype='datetime64')
    
    ts = [dt.datetime.strptime(i,'%Y-%m-%d %H:%M:%S.%f') for i in ts ]

    # ts = dt.datetime.strptime(ts, '%Y-%m-%d %H:%M:%S.%f')#  ts.astype(dt.tzinfo.dst()) # .astimezone(get_localzone()))
    #ts = ts.astimezone(get_localzone())
    
    #tstamp = data[:,1] # dt.datetime.strptime(str(data[:,0]), '%Y-%m-%d %H:%M:%S.%f')
    #ms = data[:,0]
    alt = data[:,7]
    
    if (self.comboBox.currentText() == 'Temperature'):
      var = data[:,3] # for temperature
    if (self.comboBox.currentText() == 'Relative Hum'):
      var = data[:,4] # relative Hum

    self.mpl.canvas.ax.set_xlim(xmin=min(ts), xmax=max(ts))
    xfmt = mdates.DateFormatter('%H:%M')
    self.mpl.canvas.ax.xaxis.set_major_formatter(xfmt)
    
    if (self.yaxischeckBox.isChecked() == True ):
      ymin = min(alt)
      ymax = max(alt)
      if (ymin >= -50):
	ymin = -50
	
      if (ymax >= 100):
	ymax = 100
	
      self.mpl.canvas.ax.set_ylim(ymin=ymin, ymax=ymax)
      self.mpl.canvas.ax.scatter(ts, alt , c=var, s=35, edgecolors='none')# ,
    else :
      self.mpl.canvas.ax.set_ylim(ymin=min(var), ymax=max(var))
      self.mpl.canvas.ax.scatter(ts, var, s=35, edgecolors='none')# ,
      
    self.mpl.canvas.draw()
 
    #self.mpl.canvas.xlim( min(ts),max(ts) )
    # ax.plot(ts, alt )# , 
    #self.mpl.canvas.ax.xaxis.set_major_formatter(xfmt)# 
    #self.mpl.canvas.ax.set_ylim(ymin=min(alt), ymax=max(alt))
    # self.mpl.canvas.plt.colorbar(img, cax=cax)

      
  def analyse_data(self):
  
    """Analyses a file from a senor unit"""
    
    self.kled.setColor(QtGui.QColor(255, 120, 0)) # set to yellow
    self.monitor()
    
      
  def LCD_update(self):
    
    data = self.livefeed.read_data()
    
    if (data['mcnr'] == 01):
      self.lcd_ta_1.display(data['ta'])
      self.lcd_hur_1.display(data['hur'])
      self.lcd_ps_1.display(data['ps'])
      self.lcd_ws_1.display(data['ws'])
      self.lcd_wdir_1.display(data['wdir'])
      self.lcd_alt_1.display(data['alt'])
      self.lcd_vin_1.display(data['vin'])
    
    if (data['mcnr'] == 02):
      self.lcd_ta_2.display(data['ta'])
      self.lcd_hur_2.display(data['hur'])
      self.lcd_ps_2.display(data['ps'])
      self.lcd_ws_2.display(data['ws'])
      self.lcd_wdir_2.display(data['wdir'])
      self.lcd_alt_2.display(data['alt'])
      self.lcd_vin_2.display(data['vin'])

    if (data['mcnr'] == 03):
      self.lcd_ta_3.display(data['ta'])
      self.lcd_hur_3.display(data['hur'])
      self.lcd_ps_3.display(data['ps'])
      self.lcd_ws_3.display(data['ws'])
      self.lcd_wdir_3.display(data['wdir'])
      self.lcd_alt_3.display(data['alt'])
      self.lcd_vin_3.display(data['vin'])

    if (data['mcnr'] == 04):
      self.lcd_ta_4.display(data['ta'])
      self.lcd_hur_4.display(data['hur'])
      self.lcd_ps_4.display(data['ps'])
      self.lcd_ws_4.display(data['ws'])
      self.lcd_wdir_4.display(data['wdir'])
      self.lcd_alt_4.display(data['alt'])
      self.lcd_vin_4.display(data['vin'])
    
    self.show()
  
  def record(self):

      """ Start the monitor: com_monitor thread and the update
      timer
      """
      if (self.recordButton.text() == 'Start record'):
            
	if self.com_monitor is not None or str(self.COMlineEdit.text()) == '':
	    return
	
	self.data_q = Queue.Queue()
	self.error_q = Queue.Queue()
	self.com_monitor = ComPort(
	    self.data_q, self.error_q, str(self.COMlineEdit.text()), 57600 ) # str(self.COMlineEdit.text())
	self.com_monitor.start()
	
	print "COM port is open"
	
	com_error = get_item_from_queue(self.error_q)
	
	if com_error is not None:
	    QtGui.QMessageBox.critical(self, 'Com_Port error',
		com_error)
	    self.com_monitor = None
	    self.kled.setColor(QtGui.QColor(128, 0, 0)) # set to red

	self.monitor_active = True
	
	self.timer = QtCore.QTimer()
	self.connect(self.timer, QtCore.SIGNAL('timeout()'), self.on_timer)
	self.timer.start(0.001) # / update_freq) # manuelles veraendern ablesen der seriellen schnittstelle
	# Here set color change for LCD light
	self.kled.setColor(QtGui.QColor(0, 128, 0)) # set to green
	self.recordButton.setText('STOP')
	
      else: #   (self.recordButton.text() == 'STOP'): 

	""" Stop the serial port"""
	if self.com_monitor is not None:
	    self.com_monitor.join(0.01)
	    self.com_monitor = None

	self.monitor_active = False
	self.timer.stop()
  #        self.set_actions_enable_state()
	
	print "Com port is closed"
	self.kled.setColor(QtGui.QColor(128, 0, 0)) # set to red
	self.recordButton.setText('Start record')
      
  def read_serial_data(self):
      """ Called periodically by the update timer to read data
	  from the serial port."""
	  
      qdata = list(get_all_from_queue(self.data_q))
      if len(qdata) > 0:
	print qdata # ['\x01\x001320880,BMP,25.2,998.85,HYT271,19.32,53.94,WS,NA,GY50,3,20,13,HMC,-133,-618,-57,M2125,32,1024,Vin,728.0,MC,1\r\n']

	rdata = str(qdata).split(',')# ).replace("'",'').replace("(",'').replace("NA",'NaN')
	
	print rdata # ['\x01\x001320880','BMP', '25.2', '998.85', 'HYT271', '19.32', '53.94', 'WS', 'NA', 'GY50', '3', '20', '13', 'HMC', '-133', '-618', '-57', 'M2125', '32', '1024', 'Vin', '728.0', 'MC', '1\r\n'] 1320880,BMP,25.2,998.85,HYT271,19.32,53.94,WS,NA,GY50,3,20,13,HMC,-133,-618,-57,M2125,32,1024,Vin,728.0,MC,1

	##1017879,BMP,25.0,998.85,HYT271,19.91,51.97,WS,NA,GY50,7,12,12,HMC,-135,-617,-62,M2125,32,1024,Vin,731.0,MC,1
	## 872080,BMP,26.9,1001.66,HYT271,20.62,52.94,WS,NA,GY50,8,-17,21,HMC,474,-228,-27,M2125,-144,1032,Vin,677.0,MC,2
	ms = float(str('NaN')) #rdata[0] # milliseconds
	ta_int = float(str(rdata[2]).replace(" ",'').replace("NA",'NaN'))# rdata[2] # ).replace(" ",'').replace("NA",'NaN')) #.split(',')[2].replace(" ",'').replace("NA",'NaN')) # temperature intern box
	ps = float(str(rdata[3]).replace(" ",'').replace("NA",'NaN')) # .split(',')[3].replace(" ",'').replace("NA",'NaN'))     # pressure
	ta = float(str(rdata[5]).replace(" ",'').replace("NA",'NaN')) #.split(',')[5].replace(" ",'').replace("NA",'NaN'))     # temperature
	hur = float(str(rdata[6]).replace(" ",'').replace("NA",'NaN'))# .split(',')[6].replace(" ",'').replace("NA",'NaN'))    # rel humidity 
	ws = float('NaN')# float(str(rdata[7]).replace(" ",'').replace("NA",'NaN')) # .split(',')[8].replace(" ",'').replace("NA",'NaN'))     # wind speed 
	GY50_x = float(str(rdata[10]).replace(" ",'').replace("NA",'NaN'))# .split(',')[10].replace(" ",'').replace("NA",'NaN'))# Winkelstellung
	GY50_y = float(str(rdata[11]).replace(" ",'').replace("NA",'NaN'))# .split(',')[11].replace(" ",'').replace("NA",'NaN'))# Winkelstellung
	GY50_z = float(str(rdata[12]).replace(" ",'').replace("NA",'NaN'))# .split(',')[12].replace(" ",'').replace("NA",'NaN'))# Winkelstellung
	x_dir = float(str(rdata[14]).replace(" ",'').replace("NA",'NaN'))# .split(',')[14].replace(" ",'').replace("NA",'NaN')) # Kompass
	y_dir = float(str(rdata[15]).replace(" ",'').replace("NA",'NaN'))# .split(',')[15].replace(" ",'').replace("NA",'NaN')) # Kompass
	z_dir = float(str(rdata[16]).replace(" ",'').replace("NA",'NaN'))# .split(',')[16].replace(" ",'').replace("NA",'NaN')) # Kompass
	M2125_x = float(str(rdata[18]).replace(" ",'').replace("NA",'NaN'))# .split(',')[18].replace(" ",'').replace("NA",'NaN'))# Beschleunigung
	M2125_y = float(str(rdata[19]).replace(" ",'').replace("NA",'NaN'))# .split(',')[19].replace(" ",'').replace("NA",'NaN'))# Beschleunigung
	vin = float(str(rdata[21]).replace(" ",'').replace("NA",'NaN'))# .split(',')[21].replace(" ",'').replace("NA",'NaN'))   # Batterie V
	mcnr = float(str(rdata[23][0]).replace(" ",'').replace("NA",'NaN'))# .split(',')[23].replace(" ",'').replace("NA",'NaN'))  # MC Unit Number
	##mcmem = float(str(qdata[0]).split(',')[24].replace(" ",'')) # MC free Memory

	## get hight reference:
	if (self.radio_ref_1.isChecked() == True and mcnr == 1):
	  self.ps_ref = ps
	  print 'Radion Button 1'
	elif (self.radio_ref_2.isChecked() == True and mcnr == 2):
	  self.ps_ref = ps
	  print 'Radion Button 2'
	elif (self.radio_ref_3.isChecked() == True and mcnr == 3):
	  self.ps_ref = ps
	  print 'Radion Button 3'
	elif (self.radio_ref_4.isChecked() == True and mcnr == 4):
	  self.ps_ref = ps
	  print 'Radion Button 4'

	alt = []
	  # calculate ground_0
	A = float(ps/self.ps_ref)
	B = 1/5.25588
	C = pow(A,B)
	C = 1 - C
	alt = C /0.0000225577
	#print A, B, C , alt  
  
	wdir = 360 # dummy number

	data = { 'ms' : ms , 'ta_int' : ta_int, 'ps' : ps , 'ta' : ta , 'hur' : hur , 'ws':ws, 'wdir': wdir, 'GY50_x':GY50_x, 'GY50_y':GY50_y,'GY50_z':GY50_z,  'x_dir':x_dir, 'y_dir':y_dir, 'z_dir':z_dir, 'M2125_x':M2125_x, 'M2125_y':M2125_y , 'alt':alt, 'vin':vin, 'mcnr':mcnr }
	
	self.livefeed.add_data(data)
	
	print data
	
	csvpath = self.filelineEdit.text()
	csvfile = open(csvpath,'a')
	fieldnames = data.keys()
	
	#print csvpath
	
	tstmp = dt.datetime.now()
	csvwriter = csv.writer(csvfile, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
	csvwriter.writerow([tstmp, data['ms'],data['ta_int'],data['ps'],data['ta'],data['hur'],data['ws'], data['wdir'], data['alt'], data['vin'], data['mcnr'], data['GY50_x'], data['GY50_y'], data['GY50_z'], data['x_dir'], data['y_dir'], data['z_dir'], data['M2125_x'], data['M2125_y']])
	
	#csvwriter = csv.DictWriter(csvfile ,delimiter=',', fieldnames=fieldnames)
	#csvwriter.writerow(dict((fn,fn) for fn in fieldnames))
	#for row in data:
	  #csvwriter.writerow(row)
	csvfile.close()
      
  def on_timer(self):
      """ Executed periodically when the monitor update timer
	  is fired.
      """
      self.read_serial_data()
      self.LCD_update()
      #self.monitor()
      
#  create the GUI application
app = QtGui.QApplication(sys.argv)

# instantiate the main window
dmw = DesignerMainWindow()

# show it
dmw.show()
# start the Qt main loop execution, exiting from this script
# with the same return code of Qt application
sys.exit(app.exec_())

